<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>创建和销毁对象</title>
      <link href="/2019/07/18/book/effective-java/2.%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/07/18/book/effective-java/2.%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-创建和销毁对象"><a href="#第二章-创建和销毁对象" class="headerlink" title="第二章 创建和销毁对象"></a>第二章 创建和销毁对象</h1><h2 id="1-考虑用静态工厂方法代替构造器"><a href="#1-考虑用静态工厂方法代替构造器" class="headerlink" title="1.考虑用静态工厂方法代替构造器"></a>1.考虑用静态工厂方法代替构造器</h2><blockquote><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4></blockquote><ul><li>有名称，易于理解</li><li>可以重复利用对象，避免创建重复的对象</li><li>可以返回原返回类型的任何子类型对象</li></ul><h2 id="2-遇到多个构造器参数时要考虑用构建器"><a href="#2-遇到多个构造器参数时要考虑用构建器" class="headerlink" title="2.遇到多个构造器参数时要考虑用构建器"></a>2.遇到多个构造器参数时要考虑用构建器</h2><blockquote><h4 id="三种模式："><a href="#三种模式：" class="headerlink" title="三种模式："></a>三种模式：</h4></blockquote><h5 id="1-构造器模式"><a href="#1-构造器模式" class="headerlink" title="1. 构造器模式"></a>1. 构造器模式</h5><ul><li>当很多参数的时候，难编写，难阅读</li></ul><h5 id="2-JavaBeans模式"><a href="#2-JavaBeans模式" class="headerlink" title="2. JavaBeans模式"></a>2. JavaBeans模式</h5><ul><li>调用无参构造器创建对象，然后调用setter方法赋值</li><li>弥补构造器模式的缺点，创建对象容易，易阅读</li><li>set过程被分到几个调用中，JavaBean可能处于不一致状态，需要额外保证线程安全<h5 id="3-Builder模式"><a href="#3-Builder模式" class="headerlink" title="3. Builder模式"></a>3. Builder模式</h5></li><li>客户端利用所有必要的参数调用构造器得到builder对象，然后客户端在builder对象上调用类似setter的方法，来设置可选的参数，最后客户端调用无参的build方法生成不可变对象。</li></ul><blockquote><p>示例</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Builder Pattern - Pages 14-15</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NutritionFacts</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> servingSize<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> servings<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> calories<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> fat<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> sodium<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> carbohydrate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Required parameters</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> servingSize<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> servings<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Optional parameters - initialized to default values</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> calories      <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> fat           <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> carbohydrate  <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> sodium        <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Builder</span><span class="token punctuation">(</span><span class="token keyword">int</span> servingSize<span class="token punctuation">,</span> <span class="token keyword">int</span> servings<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>servingSize <span class="token operator">=</span> servingSize<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>servings    <span class="token operator">=</span> servings<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> Builder <span class="token function">calories</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span>            <span class="token punctuation">{</span> calories <span class="token operator">=</span> val<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> Builder <span class="token function">fat</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span>            <span class="token punctuation">{</span> fat <span class="token operator">=</span> val<span class="token punctuation">;</span>           <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> Builder <span class="token function">carbohydrate</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span>            <span class="token punctuation">{</span> carbohydrate <span class="token operator">=</span> val<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> Builder <span class="token function">sodium</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span>            <span class="token punctuation">{</span> sodium <span class="token operator">=</span> val<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> NutritionFacts <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NutritionFacts</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">NutritionFacts</span><span class="token punctuation">(</span>Builder builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        servingSize  <span class="token operator">=</span> builder<span class="token punctuation">.</span>servingSize<span class="token punctuation">;</span>        servings     <span class="token operator">=</span> builder<span class="token punctuation">.</span>servings<span class="token punctuation">;</span>        calories     <span class="token operator">=</span> builder<span class="token punctuation">.</span>calories<span class="token punctuation">;</span>        fat          <span class="token operator">=</span> builder<span class="token punctuation">.</span>fat<span class="token punctuation">;</span>        sodium       <span class="token operator">=</span> builder<span class="token punctuation">.</span>sodium<span class="token punctuation">;</span>        carbohydrate <span class="token operator">=</span> builder<span class="token punctuation">.</span>carbohydrate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        NutritionFacts cocaCola <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NutritionFacts<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token number">240</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">.</span>            <span class="token function">calories</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sodium</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">carbohydrate</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="3-用私有构造器或枚举类型强化singleton属性"><a href="#3-用私有构造器或枚举类型强化singleton属性" class="headerlink" title="3. 用私有构造器或枚举类型强化singleton属性"></a>3. 用私有构造器或枚举类型强化singleton属性</h2><blockquote><h4 id="Singleton指仅被实例化一次的类"><a href="#Singleton指仅被实例化一次的类" class="headerlink" title="Singleton指仅被实例化一次的类"></a>Singleton指仅被实例化一次的类</h4></blockquote><ul><li>包含单个元素的枚举类型也可以实现Singleton</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> Elvis <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">leaveTheBuilding</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="4-通过私有构造器强化不可实例化的能力"><a href="#4-通过私有构造器强化不可实例化的能力" class="headerlink" title="4. 通过私有构造器强化不可实例化的能力"></a>4. 通过私有构造器强化不可实例化的能力</h2><ul><li>例如：java.util.Arrays，java.util.Collections</li><li>企图通过将类做成抽象类来强制该类不可被实例化，这是行不通的。该类可以被子类化，且子类可以被实例化，这样做甚至会误导用户以为该类是为了继承而设计。</li></ul><h2 id="5-避免创建不必要的对象"><a href="#5-避免创建不必要的对象" class="headerlink" title="5. 避免创建不必要的对象"></a>5. 避免创建不必要的对象</h2><h2 id="6-消除过期的对象引用"><a href="#6-消除过期的对象引用" class="headerlink" title="6. 消除过期的对象引用"></a>6. 消除过期的对象引用</h2><h2 id="7-避免使用终结方法"><a href="#7-避免使用终结方法" class="headerlink" title="7. 避免使用终结方法"></a>7. 避免使用终结方法</h2>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effective java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化</title>
      <link href="/2019/07/18/book/effective-java/11.%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2019/07/18/book/effective-java/11.%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="第十一章-序列化"><a href="#第十一章-序列化" class="headerlink" title="第十一章 序列化"></a>第十一章 序列化</h1><h2 id="74-谨慎的实现serializable接口"><a href="#74-谨慎的实现serializable接口" class="headerlink" title="74. 谨慎的实现serializable接口"></a>74. 谨慎的实现serializable接口</h2><blockquote><p>实现serializable的代价</p><ol><li>最大的代价：一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性</li><li>增加了出现bug和安全漏洞的可能性，反序列化是一个隐藏的构造器，依靠默认的反序列化机制，很容易是对象的约束关系遭到破坏，以及遭到非法访问</li><li>随着类发行新的版本，相关的测试负担也增加了。一个可序列化的类被修改时，要检查是否可以“在新版本中序列化一个实例，在旧版本中反序列化该实例”，反之亦然。</li></ol></blockquote><ul><li>为了继承而设计的类应该尽可能少的去实现Serializable接口，用户自定义的接口也应该尽可能少的继承Serializable接口。例外，Throwable、Component和HttpServlet抽象类</li><li>内部类不应该实现Serializable即可</li><li>静态成员类可以实现Serializable接口</li></ul><h2 id="75-考虑使用自定义的序列化形式"><a href="#75-考虑使用自定义的序列化形式" class="headerlink" title="75. 考虑使用自定义的序列化形式"></a>75. 考虑使用自定义的序列化形式</h2><p>-对于一个对象来说，理想的序列化形式应该只包含该对象所表示的逻辑数据，而逻辑数据与物理表示法（存储结构）应该是独立的。如果一个对象的物理表示法等同于它的逻辑内容，就适用于使用默认的序列化形式。如：</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Name</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Last name. Must be non-null.     * @serial      */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> String lastName<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * first name. Must be non-null.     * @serial      */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> String firstName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> String middleName<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span></code></pre><p> 在这段代码中，Name类的实例域精确的反应了它的逻辑内容，可以使用默认的序列化形式。注意：虽然lastName、firstName和middleName域是私有的，但它们仍然需要有注释文档。因为，这些私有域定义了一个公有的API，即这个类的序列化形式。@serial标签用来告知Javadoc工具，把这些文档信息放在有关序列化形式的特殊文档页中。</p><p>当一个对象的物理表示法与它的逻辑内容之间有实质性的不同时，使用默认序列化形式有如下缺点：</p><ul><li>它将这个类的导出API永远束缚在了该类的内部表示法上。如，私有内部类变成公有API的一部分。</li><li>会消耗过多的空间和时间</li><li>会引起栈溢出</li><li>其约束关系可能遭到严重破坏，如散列表</li></ul><p>如：</p><pre class=" language-java"><code class="language-java">  <span class="token comment" spellcheck="true">//默认序列化形式</span>  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">StringList</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Entry head <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>        String data<span class="token punctuation">;</span>        Entry next<span class="token punctuation">;</span>        Entry previous<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span></code></pre><p>自定义序列化：</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">StringList</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不会被序列化</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> Entry head <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token punctuation">{</span>        String data<span class="token punctuation">;</span>        Entry next<span class="token punctuation">;</span>        Entry previous<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Serialize this {@code StringList} instance     *      * @serialData The size of the list (the number of strings it contains)     * is emitted ({@code int}), followed by all of its elements (each a      * {@code String}), in the proper sequence.     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span>ObjectOutputStream s<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        s<span class="token punctuation">.</span><span class="token function">defaultWriteObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Entry e <span class="token operator">=</span> head<span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next <span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span>ObjectInputStream s<span class="token punctuation">)</span>         <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException <span class="token punctuation">{</span>        s<span class="token punctuation">.</span><span class="token function">defaultReadObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span></code></pre><p>注意：尽管StringList的所有域都是transient，但writeObject和readObject的首要任务仍是调用defaultXxxObject方法，这样可以极大的增强灵活性。另外尽管writeObject是私有的，仍然需要文档注释。</p><p>无论自定义序列化还是默认序列化，对于一个线程安全的对象，必须在序列化方法上强制同步。如：</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">private</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span>ObjectOutputStream s<span class="token punctuation">)</span>     <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    s<span class="token punctuation">.</span><span class="token function">defaultWriteObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><blockquote><p>总之，当要将一个类序列化时，应该仔细考虑采用默认序列化还是自定义序列化。选择错误的序列化形式对于一个类的复杂性和性能都会有永久的负面影响</p></blockquote><h2 id="76-保护性编写readObject方法"><a href="#76-保护性编写readObject方法" class="headerlink" title="76. 保护性编写readObject方法"></a>76. 保护性编写readObject方法</h2><blockquote><p>编写readObject方法的指导原则</p></blockquote><ul><li>对于对象引用域必须保持为私有的类，要保护性的拷贝这些域中的每个对象</li><li>对于任何约束条件，若检查失败，则抛出一个InvalidObjectException异常。检查应在保护性拷贝之后</li><li>无论直接方式还是间接方式，都不要调用类中任何可被覆盖的方法，否则反序列时可能会失败</li></ul><h2 id="77-对于实例控制，枚举类型优先于readResolve"><a href="#77-对于实例控制，枚举类型优先于readResolve" class="headerlink" title="77. 对于实例控制，枚举类型优先于readResolve"></a>77. 对于实例控制，枚举类型优先于readResolve</h2><ul><li>应该尽可能的使用枚举类型来实施实例控制的约束条件，若做不到，就必须提供一个readResolve方法，并将引用类型的域声明为transient的</li></ul><h2 id="78-考虑用序列化代理代替序列化实例"><a href="#78-考虑用序列化代理代替序列化实例" class="headerlink" title="78. 考虑用序列化代理代替序列化实例"></a>78. 考虑用序列化代理代替序列化实例</h2><p>序列化代理模式能够极大的减少实现Serializable接口所带来的风险。</p><p>实现序列化代理模式的步骤：</p><ul><li><p>首先为可序列化的类设计一个私有的静态嵌套类，精确的表示外围类实例的逻辑状态。它有一个单独的构造器，其参数类型为外围类。外围类及其序列化代理都必须实现Serializable接口。</p></li><li><p>将writeReplace方法添加到外围类中。</p></li><li><p>在SerializableProxy类中提供readResolve方法，它返回逻辑上相等的外围类的实例。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//外围类不需要serialVersionUID</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Period</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> Date start<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> Date end<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">Period</span><span class="token punctuation">(</span>Date start<span class="token punctuation">,</span> Date end<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>end<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>start<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>end<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>           <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>start <span class="token operator">+</span> <span class="token string">" after "</span> <span class="token operator">+</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> Date <span class="token function">getStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> Date <span class="token function">getEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>end<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//在序列化之前，将外围类的实例转变成它的序列化代理</span>  <span class="token keyword">private</span> Object <span class="token function">writeReplace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SerializationProxy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//防止被攻击者使用</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span>ObjectInputStream stream<span class="token punctuation">)</span>       <span class="token keyword">throws</span> InvalidObjectException<span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvalidObjectException</span><span class="token punctuation">(</span><span class="token string">"Proxy required"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SerializationProxy</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">final</span> Date start<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">final</span> Date end<span class="token punctuation">;</span>      <span class="token function">SerializationProxy</span><span class="token punctuation">(</span>Period p<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> p<span class="token punctuation">.</span>start<span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> p<span class="token punctuation">.</span>end<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">private</span> Object <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Period</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>正如保护性拷贝一样，序列化代理可以阻止伪字节流的攻击及内部域的盗用攻击。与使用保护性拷贝不同，使用序列化代理允许Period的域为final的，这可以保证Period类真正不可变。序列化代理模式更容易实现，它不必考虑哪些域会被序列化攻击，也不必显示的执行有效性检查。</p></li></ul><p>序列化代理的局限性：不能与可以被客户端扩展的类兼容，也不能与对象图中包含循环的类兼容，比保护性拷贝性能低</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effective java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和接口</title>
      <link href="/2019/07/18/book/effective-java/4.%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/07/18/book/effective-java/4.%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-类和接口"><a href="#第四章-类和接口" class="headerlink" title="第四章 类和接口"></a>第四章 类和接口</h1><h2 id="13-使类和成员的可访性最小化"><a href="#13-使类和成员的可访性最小化" class="headerlink" title="13. 使类和成员的可访性最小化"></a>13. 使类和成员的可访性最小化</h2><ul><li>封装：降低耦合，提高重用性</li><li>实例域决不能是公有的</li><li>公有类不应该包含公有域（除非公有静态final域），要确保公有静态final域所引用的对象都是不可变的</li></ul><h2 id="14-在公有类中使用访问方法而非公有域"><a href="#14-在公有类中使用访问方法而非公有域" class="headerlink" title="14. 在公有类中使用访问方法而非公有域"></a>14. 在公有类中使用访问方法而非公有域</h2><h2 id="15-使可变性最小化"><a href="#15-使可变性最小化" class="headerlink" title="15. 使可变性最小化"></a>15. 使可变性最小化</h2><blockquote><h4 id="使类成为不可变，需要遵循下面五条规则："><a href="#使类成为不可变，需要遵循下面五条规则：" class="headerlink" title="使类成为不可变，需要遵循下面五条规则："></a>使类成为不可变，需要遵循下面五条规则：</h4></blockquote><ol><li>不要提供任何会修改对象状态的方法</li><li>保证类不会被扩展，一般让类成为final</li><li>所有的域都是final的</li><li>所有的域都是私有的</li><li>确保对任何组件的互斥访问</li></ol><h2 id="16-组合优于继承"><a href="#16-组合优于继承" class="headerlink" title="16. 组合优于继承"></a>16. 组合优于继承</h2><ul><li>继承违背了封装的原则</li><li>使用继承要考虑子类是否和超类存在子类型的关系</li></ul><h2 id="17-要么为继承而设计，并提供文档说明，要么就禁止继承"><a href="#17-要么为继承而设计，并提供文档说明，要么就禁止继承" class="headerlink" title="17. 要么为继承而设计，并提供文档说明，要么就禁止继承"></a>17. 要么为继承而设计，并提供文档说明，要么就禁止继承</h2><h2 id="18-接口由于抽象类"><a href="#18-接口由于抽象类" class="headerlink" title="18.接口由于抽象类"></a>18.接口由于抽象类</h2><blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3></blockquote><ul><li>抽象类允许包含某些方法的实现，在java8之后接口也允许了默认方法和静态方法</li><li>抽象类是单继承，接口是多实现</li><li>现有的类可以很容易被更新，以实现新的接口</li><li>接口是定义混合类型的理想选择</li><li>接口允许我们构造非层次结构的类型框架</li></ul><h2 id="19-接口只用于定义类型，最好不要用来定义常量"><a href="#19-接口只用于定义类型，最好不要用来定义常量" class="headerlink" title="19. 接口只用于定义类型，最好不要用来定义常量"></a>19. 接口只用于定义类型，最好不要用来定义常量</h2><h2 id="20"><a href="#20" class="headerlink" title="20."></a>20.</h2><blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></blockquote><ul><li>充斥着样板代码，破坏了可读性</li><li>标签类过于冗长、容易出错、效率低下</li></ul><blockquote><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3></blockquote><ul><li>子类型化能更好的表示多种风格对象的单个数据类型<ol><li>子类型化能更好的表示多种风格对象的单个数据类型</li><li>在子类中定义属于该类的数据域</li></ol></li><li>类层次还有一个好处，增强灵活性，方便编译时类型检查。类层次能够很好的反映类型之间本质上的层次关系</li></ul><h2 id="21-用函数对象表示策略"><a href="#21-用函数对象表示策略" class="headerlink" title="21. 用函数对象表示策略"></a>21. 用函数对象表示策略</h2><ol><li><p>函数指针的主要用途就是实现策略（Strategy）模式。</p></li><li><p>为了在Java中实现这种模式，要声明一个接口来表示该策略，并且为每个具体策略声明一个实现了该接口的类。</p></li><li><p>当一个具体策略只被使用一次时，通常使用匿名类来声明和实例化这个具体策略类。</p></li><li><p>当一个具体策略是设计用来重复使用的时候，它的类通常就要被实现为私有的静态成员类，并通过公有的静态final域被导出，其类型为该策略接口</p></li><li><p>java8的lambda表达式，函数式编程也是属于这个范畴</p></li></ol><h2 id="22-优先考虑静态成员类"><a href="#22-优先考虑静态成员类" class="headerlink" title="22. 优先考虑静态成员类"></a>22. 优先考虑静态成员类</h2><blockquote><p>嵌套类</p></blockquote><p>指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为他的外围类（enclosing class）提供服务。如果嵌套类将来可以回用于其他的某个环境中，他就应该是顶层类（top-level class）</p><blockquote><p>分类</p></blockquote><p>嵌套类分为四种：静态成员类（static member class）、非静态成员类（nonstatic member class）、匿名类（anonymous class）和局部类（local class）。<br>内部类：非静态成员类（nonstatic member class）、匿名类（anonymous class）和局部类（local class）</p><blockquote><p>静态成员类</p></blockquote><p>静态成员类是最简单的一种嵌套类。<br>最好把他看做是普通的类，只是碰巧被声明在另一个类的内部而已，他可以访问外围类的所有成员，包括声明为私有的成员。<br>静态内部类是外围类的一个静态成员，与其他的静态成员一样，也最受同样的可访问性规则。如果他被声明为私有的，他就只能在外围类的内部才可以被访问，等等。</p><ul><li>注意：如果一个类要被声明为static的，只有一种情况，就是静态内部类。如果在外部类声明为static，程序会编译都不会过。</li></ul><blockquote><p>非静态成员类</p></blockquote><p>从语法上讲，静态成员类和非静态成员类之间唯一的区别是：静态成员类的声明中包含修饰符static。尽管他们语法非常相似，但是这两种嵌套类有很大的不同。<br>非静态成员类的每个实例都隐含着与外围类的一个外围实例（enclosing instance）想关联。在非静态成员类的实例方法内部，可以调用外围实例上的方法，或者利用修饰过的this构造获得外围实例的引用。如果嵌套类的实例可以在他外围实例的情况下，要想创建非静态成原来的实例是不可能的</p><blockquote><p>匿名类</p></blockquote><ol><li>第一种常见用法就是动态的创建函数对象（function object）</li><li>第二种常见的用法是创建过程对象（process object），比如Runnable、Thread或者TimerTask实例。</li><li>第三种常见的用法是在静态工厂内部</li></ol><blockquote><p>局部类</p></blockquote><p>局部类是四种嵌套类中用的最少的类。在任何“可以声明局部变量”的地方，都可以声明局部类，并且局部类也遵守同样的作用域规则。局部类与其他三种嵌套类中的每一种都有一些共同的属性。与成员类一样，局部类有名字，可以被重复使用。与匿名类一样，只有当局部类实在非静态环境中定义的时候，才有外围实例，它们也不能包含静态成员。与匿名类一样，它们必须简短以便不会影响到可读性</p><blockquote><p>使用总结</p></blockquote><ol><li>如果一个嵌套类需要在单个方法之外仍然可见的，或者它太长了，不适合于放在方法内部，就应该使用成员类。</li><li>如果成员类的每个示例都需要一个指向外围实例的引用，就要把成员类做成非静态的；否则，就做成静态的。</li><li>假设这个嵌套类属于一个方法的内部，如果你只需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类的特征，就要把它做成匿名类；否则，就做成局部类</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effective java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于所有对象都通用的方法</title>
      <link href="/2019/07/18/book/effective-java/3.%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2019/07/18/book/effective-java/3.%E5%AF%B9%E4%BA%8E%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-对于所有对象都通用的方法"><a href="#第三章-对于所有对象都通用的方法" class="headerlink" title="第三章 对于所有对象都通用的方法"></a>第三章 对于所有对象都通用的方法</h1><h2 id="8-实现高质量equals方法的诀窍"><a href="#8-实现高质量equals方法的诀窍" class="headerlink" title="8. 实现高质量equals方法的诀窍"></a>8. 实现高质量equals方法的诀窍</h2><ol><li>使用==操作符检查“参数是否为这个对象的引用”，如果是，返回true；</li><li>使用instanceof操作符检查“参数是否为正确类型”，所谓正确类型，是指equals所在的类，有些情况下是指该类实现的某个接口；</li><li>把参数转换成正确类型，因为转换之前进行过instanceof的测试，所以会确保成功；</li><li>对于该类中的每个“关键”域，检查参数中的域是否与该对象对应的域相匹配；为了获得最佳的性能，应该优先比较最可能不一致的域；</li><li>编写完的equals方法要保证：对称性、一致性、传递性；</li><li>覆盖equals时总要覆盖hashCode</li><li>不要将equals方法中的Object对象替换为其他类型的对象；</li></ol><h2 id="9-覆盖equals时总要覆盖hashCode"><a href="#9-覆盖equals时总要覆盖hashCode" class="headerlink" title="9. 覆盖equals时总要覆盖hashCode"></a>9. 覆盖equals时总要覆盖hashCode</h2><ol><li>equals相同，hashcode一定相同；</li><li>equals不同，hashcode不一定不同；</li><li>一个好的散列函数通常倾向于“为不相等的对象产生不相等的散列码”；</li></ol><h2 id="10-始终要覆盖toString"><a href="#10-始终要覆盖toString" class="headerlink" title="10. 始终要覆盖toString"></a>10. 始终要覆盖toString</h2><h2 id="11-谨慎的覆盖clone"><a href="#11-谨慎的覆盖clone" class="headerlink" title="11. 谨慎的覆盖clone"></a>11. 谨慎的覆盖clone</h2><blockquote><p>尤其是对象的属性是引用类型的，需要手动来深度拷贝</p></blockquote><h2 id="12-考虑实现comparable接口"><a href="#12-考虑实现comparable接口" class="headerlink" title="12. 考虑实现comparable接口"></a>12. 考虑实现comparable接口</h2>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effective java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举和注解</title>
      <link href="/2019/07/18/book/effective-java/6.%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/07/18/book/effective-java/6.%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="第六章-枚举和注解"><a href="#第六章-枚举和注解" class="headerlink" title="第六章 枚举和注解"></a>第六章 枚举和注解</h1><h2 id="30-用enum代替int常量"><a href="#30-用enum代替int常量" class="headerlink" title="30. 用enum代替int常量"></a>30. 用enum代替int常量</h2><h2 id="31-用实例域代替序数"><a href="#31-用实例域代替序数" class="headerlink" title="31. 用实例域代替序数"></a>31. 用实例域代替序数</h2><h2 id="32-用EnumSet代替位域"><a href="#32-用EnumSet代替位域" class="headerlink" title="32. 用EnumSet代替位域"></a>32. 用EnumSet代替位域</h2><ul><li>EnumSet是线程不安全的，需要借助Collections.synchronizedSet</li></ul><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>MyEnum<span class="token operator">></span> s <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedSet</span><span class="token punctuation">(</span>EnumSet<span class="token punctuation">.</span><span class="token function">noneOf</span><span class="token punctuation">(</span>MyEnum<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="33-用EnumMap代替序数索引"><a href="#33-用EnumMap代替序数索引" class="headerlink" title="33. 用EnumMap代替序数索引"></a>33. 用EnumMap代替序数索引</h2><h2 id="34-用接口模拟可伸缩的枚举"><a href="#34-用接口模拟可伸缩的枚举" class="headerlink" title="34. 用接口模拟可伸缩的枚举"></a>34. 用接口模拟可伸缩的枚举</h2><h2 id="35-注解优于命名模式"><a href="#35-注解优于命名模式" class="headerlink" title="35. 注解优于命名模式"></a>35. 注解优于命名模式</h2><h2 id="36-坚持使用Override注解"><a href="#36-坚持使用Override注解" class="headerlink" title="36. 坚持使用Override注解"></a>36. 坚持使用Override注解</h2><h2 id="37-用标记接口定义类型"><a href="#37-用标记接口定义类型" class="headerlink" title="37. 用标记接口定义类型"></a>37. 用标记接口定义类型</h2><ul><li>标记接口是没有包含方法声明的接口，而只是标明一个类实现了具有某种属性的接口</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effective java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2019/07/18/book/effective-java/5.%E6%B3%9B%E5%9E%8B/"/>
      <url>/2019/07/18/book/effective-java/5.%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-泛型"><a href="#第五章-泛型" class="headerlink" title="第五章 泛型"></a>第五章 泛型</h1><h2 id="23-不要使用原生态类型，要使用泛型"><a href="#23-不要使用原生态类型，要使用泛型" class="headerlink" title="23. 不要使用原生态类型，要使用泛型"></a>23. 不要使用原生态类型，要使用泛型</h2><h2 id="24-消除非受检警告"><a href="#24-消除非受检警告" class="headerlink" title="24. 消除非受检警告"></a>24. 消除非受检警告</h2><p>@SuperWarnings(“unchecked”)要尽可能小的范围</p><h2 id="25-列表优于数组"><a href="#25-列表优于数组" class="headerlink" title="25. 列表优于数组"></a>25. 列表优于数组</h2><h2 id="26-优先考虑泛型"><a href="#26-优先考虑泛型" class="headerlink" title="26. 优先考虑泛型"></a>26. 优先考虑泛型</h2><h2 id="27-优先考虑泛型方法"><a href="#27-优先考虑泛型方法" class="headerlink" title="27. 优先考虑泛型方法"></a>27. 优先考虑泛型方法</h2><h2 id="28-利用有限制通配符来提升api的灵活性"><a href="#28-利用有限制通配符来提升api的灵活性" class="headerlink" title="28. 利用有限制通配符来提升api的灵活性"></a>28. 利用有限制通配符来提升api的灵活性</h2><h2 id="29-优先考虑类型安全的异构容器"><a href="#29-优先考虑类型安全的异构容器" class="headerlink" title="29. 优先考虑类型安全的异构容器"></a>29. 优先考虑类型安全的异构容器</h2>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effective java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法</title>
      <link href="/2019/07/18/book/effective-java/7.%E6%96%B9%E6%B3%95/"/>
      <url>/2019/07/18/book/effective-java/7.%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-方法"><a href="#第七章-方法" class="headerlink" title="第七章 方法"></a>第七章 方法</h1><h2 id="38-检查参数的有效性"><a href="#38-检查参数的有效性" class="headerlink" title="38. 检查参数的有效性"></a>38. 检查参数的有效性</h2><h2 id="39-必要时进行保护性拷贝"><a href="#39-必要时进行保护性拷贝" class="headerlink" title="39. 必要时进行保护性拷贝"></a>39. 必要时进行保护性拷贝</h2><ul><li>保护性拷贝实在参数有效性检查(38)之前进行的，而且有效性检查是针对拷贝之后的对象，这样做可以避免从检查参数到拷贝对象之间的时间段内从另一个线程改变类的参数</li></ul><h2 id="40-谨慎设计方法签名"><a href="#40-谨慎设计方法签名" class="headerlink" title="40. 谨慎设计方法签名"></a>40. 谨慎设计方法签名</h2><ul><li>谨慎选择方法的名称：遵守命名规范、易于理解</li><li>不要过于追求提供便利的方法：方法职责清晰、小方法</li><li>避免过长的参数列表：&lt;=4<ol><li>方法拆分</li><li>创建辅助类，用来保存参数的分组，这些辅助类一般为静态成员类(22)</li><li>从对象构建到方法调用都采用builder模式(2)</li></ol></li><li>对于参数类型，优先使用接口而不是类</li><li>对于boolean参数，优先使用两个元素的枚举类型</li></ul><h2 id="41-慎用重载"><a href="#41-慎用重载" class="headerlink" title="41. 慎用重载"></a>41. 慎用重载</h2><ul><li>对于要调用哪个重载方法，是在编译时作出的决定</li><li>覆盖(Override)方法的选择是在运行时作出的</li></ul><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>result：<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span></code></pre><p>原因：List的remove方法有两个重载方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span><span class="token punctuation">;</span>E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span></code></pre><p>Integer类型时是移除对象，而int时是移除制定位置的值</p><blockquote><h4 id="使用重载方法至少应该避免以下情形："><a href="#使用重载方法至少应该避免以下情形：" class="headerlink" title="使用重载方法至少应该避免以下情形："></a>使用重载方法至少应该避免以下情形：</h4></blockquote><ul><li>同一组参数只需经过类型转换就可以传递给不同的重载方法</li></ul><h5 id="要保证传递同样的参数，所有重载方法的行为必须一致"><a href="#要保证传递同样的参数，所有重载方法的行为必须一致" class="headerlink" title="要保证传递同样的参数，所有重载方法的行为必须一致"></a>要保证传递同样的参数，所有重载方法的行为必须一致</h5><h2 id="42-慎用可变参数"><a href="#42-慎用可变参数" class="headerlink" title="42. 慎用可变参数"></a>42. 慎用可变参数</h2><h2 id="43-返回0长度的数组或者集合，而不是null"><a href="#43-返回0长度的数组或者集合，而不是null" class="headerlink" title="43. 返回0长度的数组或者集合，而不是null"></a>43. 返回0长度的数组或者集合，而不是null</h2><h2 id="44-为所有导出的api元素编写文档注释"><a href="#44-为所有导出的api元素编写文档注释" class="headerlink" title="44. 为所有导出的api元素编写文档注释"></a>44. 为所有导出的api元素编写文档注释</h2>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effective java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/2019/07/18/book/effective-java/9.%E5%BC%82%E5%B8%B8/"/>
      <url>/2019/07/18/book/effective-java/9.%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="第九章-异常"><a href="#第九章-异常" class="headerlink" title="第九章 异常"></a>第九章 异常</h1><h2 id="57-只针对异常的情况才使用异常"><a href="#57-只针对异常的情况才使用异常" class="headerlink" title="57. 只针对异常的情况才使用异常"></a>57. 只针对异常的情况才使用异常</h2><h2 id="58-对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#58-对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="58. 对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>58. 对可恢复的情况使用受检异常，对编程错误使用运行时异常</h2><h2 id="59-避免不必要的使用受检的异常"><a href="#59-避免不必要的使用受检的异常" class="headerlink" title="59. 避免不必要的使用受检的异常"></a>59. 避免不必要的使用受检的异常</h2><h2 id="60-优先使用标准的异常"><a href="#60-优先使用标准的异常" class="headerlink" title="60. 优先使用标准的异常"></a>60. 优先使用标准的异常</h2><ul><li>最好重用现有的异常</li></ul><h2 id="61-抛出与抽象对应的异常"><a href="#61-抛出与抽象对应的异常" class="headerlink" title="61. 抛出与抽象对应的异常"></a>61. 抛出与抽象对应的异常</h2><h2 id="62-每个方法抛出的异常都要有文档"><a href="#62-每个方法抛出的异常都要有文档" class="headerlink" title="62. 每个方法抛出的异常都要有文档"></a>62. 每个方法抛出的异常都要有文档</h2><h2 id="63-在细节消息中包含能捕获失败的信息"><a href="#63-在细节消息中包含能捕获失败的信息" class="headerlink" title="63. 在细节消息中包含能捕获失败的信息"></a>63. 在细节消息中包含能捕获失败的信息</h2><ul><li>为了捕获失败，异常的细节信息应该包含所有“对该异常有贡献”的参数和域的值</li></ul><h2 id="64-努力使失败保持原子性"><a href="#64-努力使失败保持原子性" class="headerlink" title="64. 努力使失败保持原子性"></a>64. 努力使失败保持原子性</h2><blockquote><p>失败原子性：一般而言，失败的方法调用应该使对象保持在被调用之前的状态</p></blockquote><p>实现失败原子性的几种途径：</p><ol><li>设计一个不可变的对象</li><li>对于可变对象，在执行操作之前检查参数的有效性，使得在对象状态被修改之前，先抛出适当的异常</li><li>编写一段恢复代码（远没有那么常用）</li></ol><h2 id="65-不要忽略异常"><a href="#65-不要忽略异常" class="headerlink" title="65. 不要忽略异常"></a>65. 不要忽略异常</h2>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effective java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通用程序设计</title>
      <link href="/2019/07/18/book/effective-java/8.%E9%80%9A%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/07/18/book/effective-java/8.%E9%80%9A%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-通用程序设计"><a href="#第八章-通用程序设计" class="headerlink" title="第八章 通用程序设计"></a>第八章 通用程序设计</h1><h2 id="45-将局部变量的作用域最小化"><a href="#45-将局部变量的作用域最小化" class="headerlink" title="45. 将局部变量的作用域最小化"></a>45. 将局部变量的作用域最小化</h2><ul><li>要使局部变量作用域最小化的最有力的方法就只在第一次使用它的地方声明</li><li>另一个有效方法是使方法小而集中</li></ul><h2 id="46-for-each循环优于传统的for循环"><a href="#46-for-each循环优于传统的for循环" class="headerlink" title="46. for-each循环优于传统的for循环"></a>46. for-each循环优于传统的for循环</h2><blockquote><p>有三种常见的情况无法使用for-each</p></blockquote><ol><li>过滤——如果需要遍历集合，并删除指定的元素，就需要使用显示的迭代器，以便可以调用它的remove方法</li><li>转换——如果需要遍历列表或数组，并取代它部分或全部的元素值，就需要列表迭代器或数组索引，以便设定元素的值</li><li>平行迭代——如果需要并行的遍历多个集合，就需要显示的控制迭代器或索引变量，以便所有迭代器或索引变量可以同步前移</li></ol><h2 id="47-了解和使用类库"><a href="#47-了解和使用类库" class="headerlink" title="47. 了解和使用类库"></a>47. 了解和使用类库</h2><h2 id="48-如果需要精确的答案，不要使用float和double"><a href="#48-如果需要精确的答案，不要使用float和double" class="headerlink" title="48. 如果需要精确的答案，不要使用float和double"></a>48. 如果需要精确的答案，不要使用float和double</h2><blockquote><p>使用bigdecimal、int、long进行货币运算</p></blockquote><ul><li>BigDecimal：法定的舍入行为、性能不是太好</li><li>int：自己需要记录十进制小数点，且数值范围没有超过9位十进制数字</li><li>long：不超过18位十进制数字</li><li>如果超过18位数字，就必须使用BigDecimal</li></ul><h2 id="49-基本类型优于装箱基本类型"><a href="#49-基本类型优于装箱基本类型" class="headerlink" title="49. 基本类型优于装箱基本类型"></a>49. 基本类型优于装箱基本类型</h2><h2 id="50-如果其他类型更合适，则尽量避免使用字符串"><a href="#50-如果其他类型更合适，则尽量避免使用字符串" class="headerlink" title="50. 如果其他类型更合适，则尽量避免使用字符串"></a>50. 如果其他类型更合适，则尽量避免使用字符串</h2><ul><li>字符串不适合代替其他的值类型</li><li>字符串不适合代替枚举类型</li><li>字符串不适合代替聚焦类型</li><li>字符串也不适合代替能力表(capabilities)</li></ul><h2 id="51-当心字符串连接的性能"><a href="#51-当心字符串连接的性能" class="headerlink" title="51. 当心字符串连接的性能"></a>51. 当心字符串连接的性能</h2><ul><li>多个字符串的拼接优先使用stringbuilder（java8中对string的拼接进行了优化，默认也是使用stringbuilder）</li></ul><h2 id="52-通过接口引用对象"><a href="#52-通过接口引用对象" class="headerlink" title="52. 通过接口引用对象"></a>52. 通过接口引用对象</h2><ul><li>如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明</li></ul><h2 id="53-接口优于反射机制"><a href="#53-接口优于反射机制" class="headerlink" title="53. 接口优于反射机制"></a>53. 接口优于反射机制</h2><ul><li>通常普通应用程序在运行时不应该以反射方式访问对象</li><li>如果你编写的程序必须要与编译时未知的类一起工作，如有可能，就应该仅仅使用反射机制来实例化对象，而访问对象时则使用编译时已知的某个接口或者超类</li></ul><h2 id="54-谨慎的使用本地方法"><a href="#54-谨慎的使用本地方法" class="headerlink" title="54. 谨慎的使用本地方法"></a>54. 谨慎的使用本地方法</h2><h2 id="55-谨慎的进行优化"><a href="#55-谨慎的进行优化" class="headerlink" title="55. 谨慎的进行优化"></a>55. 谨慎的进行优化</h2><h2 id="56-遵守普遍接受的命名规范"><a href="#56-遵守普遍接受的命名规范" class="headerlink" title="56. 遵守普遍接受的命名规范"></a>56. 遵守普遍接受的命名规范</h2><ul><li><a href="https://102.alibaba.com/downloadFile.do?file=1528269849853/Java_manual.pdf" target="_blank" rel="noopener">参考阿里巴巴命名规范</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effective java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发</title>
      <link href="/2019/07/18/book/effective-java/10.%E5%B9%B6%E5%8F%91/"/>
      <url>/2019/07/18/book/effective-java/10.%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="第十章-并发"><a href="#第十章-并发" class="headerlink" title="第十章 并发"></a>第十章 并发</h1><h2 id="66-同步访问共享的可变数据"><a href="#66-同步访问共享的可变数据" class="headerlink" title="66. 同步访问共享的可变数据"></a>66. 同步访问共享的可变数据</h2><ul><li>不要使用Thread.stop。要阻止一个线程妨碍另一个线程，建议做法是让第一个线程轮询一个boolean域，这个域一开始为false，但是可以通过第二个线程设置为true，以表示第一个线程将终止自己。由于boolean域的读写是原子的，所以在访问这个域的时候不在需要同步</li></ul><h2 id="67-避免过度同步"><a href="#67-避免过度同步" class="headerlink" title="67. 避免过度同步"></a>67. 避免过度同步</h2><ul><li>过度同步可能导致性能降低、死锁，甚至不确定的行为</li><li>应该在同步区域内做尽量少的工作</li><li>为了避免死锁和数据破坏，千万不要从同步区域内部调用外来方法</li></ul><h2 id="68-executor和task优于线程"><a href="#68-executor和task优于线程" class="headerlink" title="68. executor和task优于线程"></a>68. executor和task优于线程</h2><p>java concurrent包中的Executor FrameWork是一个很灵活的基于接口的任务执行工具</p><pre class=" language-java"><code class="language-java">ExecutorService executor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 下面是为执行提交一个runable的方法</span>executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 告诉executor终止</span>executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>为不同的应用程序选择executor service是很有技巧的</p></blockquote><p>如果编写的是小程序，或者是轻载的服务器，使用Executors.newCachedThreadPool通常是个不错的选择，因为它不需要配置，并且一般情况下能够正确地工作，</p><p>但是对于大负载的服务器来说，缓存的线程池不是很好地选择了。在缓存的线程池中，被提交的任务没有排成队列，而是直接交给线程执行。如果没有线程可用，就创建一个新的线程。因此，在大负载的产品服务器中，最好使用Executors.newFixedThreadPool,它为你提供了一个包含固定线程数目的线程池</p><h2 id="69-并发工具优先于wait和notify"><a href="#69-并发工具优先于wait和notify" class="headerlink" title="69. 并发工具优先于wait和notify"></a>69. 并发工具优先于wait和notify</h2><ul><li><p>java.util.concurrent中更高级的工具分三类：Executor Framework，并发集合（Concurrent Collection）以及同步器（Synchronizer）</p></li><li><p>并发集合为标准的集合接口（如List、Queue、Map）提供了高性能的并发实现。为了提高并发性，这些实现在内部自己同步管理。因此，并发集合中不可能排除并发活动，客户无法原子地对并发集合进行方法调用。因此有些集合接口已经通过依赖状态的修改状态进行了扩展，它将几个基本操作合并到了单个原子操作中。例如：ConcurrentMap扩展了Map接口，并添加了几个方法，一般地说，优先使用并发集合，而不是使用外部同步的集合</p></li><li><p>同步器（Synchronizer）是一些使线程能够等待另一个线程的对象。允许它们协调动作，最常用的同步器是CountDownLatch和Semaphore</p><ol><li>倒计数锁存器CountDown Latch是一次性的障碍，允许一个或者多个线程等待一个或者多个其他线程来做某些事情。CountDownLatch的唯一构造器是带有一个int类型的参数，这个int类型的参数表示允许所有在等待的线程被处理之前，必须在锁存器上调用countDown方法的次数</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentCountDown</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//给一个动作的并发执行定时。</span>      <span class="token comment" spellcheck="true">/**       * @param executor:执行该动作的executor       * @param concurrency:并发级别       * @param action ：该动作的Runnable       *       * */</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">time</span><span class="token punctuation">(</span>Executor executor<span class="token punctuation">,</span> <span class="token keyword">int</span> concurrency<span class="token punctuation">,</span><span class="token keyword">final</span> Runnable              action<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">{</span>          <span class="token keyword">final</span> CountDownLatch ready <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>concurrency<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">final</span> CountDownLatch start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">final</span> CountDownLatch done <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>concurrency<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> concurrency<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token annotation punctuation">@Override</span>                  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                      ready<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//tell timer we're ready</span>                      <span class="token keyword">try</span><span class="token punctuation">{</span>                          start<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//wait till peers are ready</span>                          action<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>                          Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>                          done<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//tell timer we're done</span>                      <span class="token punctuation">}</span>                  <span class="token punctuation">}</span>              <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          ready<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//wait for all workers to be ready</span>          <span class="token keyword">long</span> startNanos <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//对于间歇式的定时，优先使用System.nanoTime</span>          start<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//and they're off</span>          done<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//wait for all work to finish</span>          <span class="token keyword">return</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startNanos<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre></li></ul><h2 id="70-线程安全性的文档化"><a href="#70-线程安全性的文档化" class="headerlink" title="70. 线程安全性的文档化"></a>70. 线程安全性的文档化</h2><ol><li><p>线程安全性有多种级别，一个类为了可被多个线程安全地使用，必须在文档中清楚地说明它所支持的线程安全性级别。常见的线程安全性级别：</p><ul><li>不可变的 Immutable：这个类的实例是不可变的，不需要外部的同步，如：String、Long和BigInteger</li><li>无条件的线程安全 unconditionally thread-safe:这个类的实例是可变的，但是这个类有着足够的内部同步，所以它的实例可以被并发使用，无需任何外部同步。如：Random和ConcurrentHashMap.</li><li>有条件的线程安全 conditionally thread-safe:除了有些方法进行安全的并发使用而需要外部同步之外，这种线程的安全级别与无条件的线程安全相同。包括Collections.synchronized包装返回的集合。</li><li>非线程安全 not thread-safe:这个类的实例是可变的，为了并发地使用它们，客户必须利用自己选择的外部同步包围每个方法调用。例子包括通用的集合实现（ArrayList和HashMap）</li><li>线程对立的 thread-hostie：这个类不能安全地被多个线程并发使用。（很少）</li></ul></li><li><p>有条件的线程安全类必须在文档中指明“哪个方法调用序列需要外部同步，以及在执行这些序列的时候需要获得哪把锁。”如果你编写的是无条件的线程安全类，就应该考虑使用私有锁对象来代替同步的方法</p></li></ol><h2 id="71-慎用延迟初始化Lazy-initialization"><a href="#71-慎用延迟初始化Lazy-initialization" class="headerlink" title="71. 慎用延迟初始化Lazy initialization"></a>71. 慎用延迟初始化Lazy initialization</h2><ul><li><p>延迟初始化是延迟到需要域的值时才将它初始化的这种行为。如果永远不需要这个值，这个域就永远不会被初始化。这种方法既适用于静态域，也适用于实例域。主要是一种优化，除非绝对必要，否则就不要这么做。延迟初始化是一把双刃剑：降低了初始化类或者创建实例的开销，却增加了访问被延迟初始化的域的开销</p></li><li><p>当有多个线程的时候，延迟初始化是需要技巧的，如果两个或者多个线程共享一个延迟初始化的域，采用某种形式的同步是很重要的，否则就会造成很严重的bug。大多数情况下，正常的初始化要优先于延时初始化：<br>private final FieldType field = computerFieldValue();<br>同步访问方法来进行延迟初始化：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> FieldType field<span class="token punctuation">;</span>  <span class="token keyword">synchronized</span> FieldType <span class="token function">getField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>field <span class="token operator">==</span>null<span class="token punctuation">)</span>      field <span class="token operator">=</span> <span class="token function">computerFieldValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> field<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre></li><li><p>如果出于性能的考虑需要对静态域进行延迟初始化，就使用lazy initialization holder class模式，这种模式保证了类要被用到时才会被初始化</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">FieldHolder</span><span class="token punctuation">{</span>  <span class="token keyword">static</span> <span class="token keyword">final</span> FieldType field <span class="token operator">=</span> <span class="token function">computerFieldValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> FieldType <span class="token function">getField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">return</span> FieldHolder<span class="token punctuation">.</span>field<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>如果出于性能的考虑需要对实例域进行延迟初始化，就使用<strong>双重检查模式</strong>double checked idiom，避免在域被初始化之后访问这个域时的锁定开销。这种模式的思想是两次检查，第一次检查使没有锁定，看看这个域是否初始化了，第二次检查时有锁定。如果域已经初始化则不会有锁定：</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">private</span> <span class="token keyword">volatile</span> FieldType field<span class="token punctuation">;</span>  FieldType <span class="token function">getField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    FieldType result <span class="token operator">=</span> field<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>result <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        result <span class="token operator">=</span> field<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>result <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>          field <span class="token operator">=</span> result <span class="token operator">=</span> <span class="token function">computerFieldValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre></li><li><p>总结：大多数的域都应该正常地进行初始化，而不是延迟初始化。如果为了达到性能目的或者为了破坏有害的初始化循环，而必须延迟初始化一个域，就可以使用相应的初始化方法</p></li></ul><h2 id="72-不要依赖线程调度器"><a href="#72-不要依赖线程调度器" class="headerlink" title="72. 不要依赖线程调度器"></a>72. 不要依赖线程调度器</h2><ul><li>任何依赖于线程调度器来达到正确性或者性能要求的程序，很有可能都是不可移植的。要编写健壮的，响应良好的、可移植的多线程应用程序，最好的办法是确保可运行线程的平均数量不明显多于处理器的数量。这使得线程调度器没有更多的选择</li><li>保持可运行线程数量尽可能少的主要方法是：让每个线程做些有意义的工作，然后等待更多有意义的工作。根据Executor Framework这意味着适当地规定了线程池的大小，并且使任务保持适当地小，彼此独立</li><li>线程不应该一直处于busy-wait状态，即反复地检查一个共享对象，以等待某些事情的发生。除了使程序易受到调度器的影响，这种做法也极大地增加了处理器的负担</li><li>不要依赖Thread.yield或者线程优先级，这些设施仅仅对调度器作出暗示。线程优先级可以用来提高一个已经能够正常工作的程序的服务质量，但永远不应该拿来修正一个原本并不能工作的程序</li></ul><h2 id="73-避免使用线程组"><a href="#73-避免使用线程组" class="headerlink" title="73. 避免使用线程组"></a>73. 避免使用线程组</h2><ul><li>线程系统处理线程、锁、监视器之外，还提供了一个基本的抽象：线程组。线程组的初衷是作为一种隔离的applet小程序机制，但是它的安全性不敢恭维。可以忽略</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> effective java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
